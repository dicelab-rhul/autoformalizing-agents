The following is a Prolog program that can be used to generate and test all legal evolutions of a game represented in the situation calculus:

% All legal evolutions of a game: can be used both as a generator and test.
game(F,F):- final(F).
game(S,F):- \+ final(S), legal(M,S), game(do(M,S),F).

The domain independent version of the situation calculus is as follows:

% Situation Calculus - our formulation for games.
holds(F, S):- initially(F, S).
holds(F, do(M, S)):- effect(F, M, S).
holds(F, do(A, S)):- holds(F, S), \+ abnormal(F, A, S).

The prisoner's dilemma game, can be specified as follows:

/* Game specific predicates for Prisoner's Dilemma (PD) */

% Payoff matrix for PD
payoff('D', 'D', 2, 2).
payoff('C', 'D', 1, 4).
payoff('D', 'C', 4, 1).
payoff('C', 'C', 3, 3).
% Initial state
initial(s0).
% What holds initially: who is a player, their role, and whether they can play.
initially(player(p1), s0).
initially(player(p2), s0).
initially(role(p1,row), s0).
initially(role(p2,col), s0).
initially(control(p1), s0).
initially(control(p2), s0).
initially(default_move(_, 'C'), s0).
% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(do(move(_P2, _M2), do(move(_P1, _M1), S))):-initial(S).
% A legal move is a possible move where the player has control (is its turn).
legal(move(P, M), S):- possible(move(P, M), S), holds(control(P), S).
% What is possible for a player to choose
possible(move(P,'D'), S):- holds(player(P), S).
possible(move(P,'C'), S):- holds(player(P), S).
% Moves that are opposite to each other.
opposite_move('C', 'D').
opposite_move('D', 'C').
% The effects of a move: if P has chosen M, then in the next state this
% is what they did.
effect(did(P, M), move(P, M), _S).
% The effects of a move: once a move is made, the player looses control, i.e.
% cannot move anymore.
abnormal(control(P), move(P, _M), _S).
% What holds finally: the outcome with players, Moves, and Utilities.
finally(outcome(P1,M1,U1,P2,M2,U2), S):-
    final(S),
    holds(role(P1, row), S),
    holds(did(P1, M1), S),
    holds(role(P2, col), S),
    holds(did(P2, M2), S),
    payoff(M1, M2, U1, U2).
% Goals achieved by the players.
finally(goal(P1, U1), S):-
    finally(outcome(P1,_,U1,_,_,_), S).
finally(goal(P2, U2), S):-
    finally(outcome(_,_,_,P2,_,U2), S).

The verbal description of a tit-for-tat strategy is as follows:

"The tit-for-tat strategy begins with a default move. Then, in each subsequent interaction, it mirrors the opponent's previous move.".

Its Prolog representation for the game specified above can be defined as follows:

% tit-for-tat strategy
select(P, O, S, M):-
    \+ holds(last_move(O, _LMo), S),
    holds(default_move(P, M), S).
select(_P, O, S, Mo):-
    holds(last_move(O, Mo), S).

Here's a description of a different strategy:

{strategy_description}

Produce Prolog representation of the new strategy for the above game. Do not use constants for the names of the moves. Mark the beginning and end of the Prolog code with a '@'. Do not put any non-Prolog syntax between '@' characters.