The following is a Prolog program that can be used to generate and test all legal evolutions of a game represented in the situation calculus:

% All legal evolutions of a game: can be used both as a generator and test.
game(F,F):- final(F).
game(S,F):- \+ final(S), legal(M,S), game(do(M,S),F).

The domain independent version of the situation calculus is as follows:

% Situation Calculus - our formulation for games.
holds(F, S):- initially(F, S).
holds(F, do(M, S)):- effect(F, M, S).
holds(F, do(A, S)):- holds(F, S), \+ abnormal(F, A, S).

The prisoner's dilemma game, can be specified as follows:

/* Game specific predicates for Prisoner's Dilemma (PD) */

% Payoff matrix for PD
payoff('D', 'D', 2, 2).
payoff('C', 'D', 1, 4).
payoff('D', 'C', 4, 1).
payoff('C', 'C', 3, 3).
% Initial state
initial(s0).
% What holds initially: who is a player, their role, and whether they can play.
initially(player(p1), s0).
initially(player(p2), s0).
initially(role(p1,row), s0).
initially(role(p2,col), s0).
initially(control(p1), s0).
initially(control(p2), s0).
initially(default_move(_, 'C'), s0).
% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(do(move(_P2, _M2), do(move(_P1, _M1), S))):-initial(S).
% A legal move is a possible move where the player has control (is its turn).
legal(move(P, M), S):- possible(move(P, M), S), holds(control(P), S).
% What is possible for a player to choose
possible(move(P,'D'), S):- holds(player(P), S).
possible(move(P,'C'), S):- holds(player(P), S).
% Moves that are opposite to each other.
opposite_move('C', 'D').
opposite_move('D', 'C').
% The effects of a move: if P has chosen M, then in the next state this
% is what they did.
effect(did(P, M), move(P, M), _S).
% The effects of a move: once a move is made, the player looses control, i.e.
% cannot move anymore.
abnormal(control(P), move(P, _M), _S).
% What holds finally: the outcome with players, Moves, and Utilities.
finally(outcome(P1,M1,U1,P2,M2,U2), S):-
    final(S),
    holds(role(P1, row), S),
    holds(did(P1, M1), S),
    holds(role(P2, col), S),
    holds(did(P2, M2), S),
    payoff(M1, M2, U1, U2).
% Goals achieved by the players.
finally(goal(P1, U1), S):-
    finally(outcome(P1,_,U1,_,_,_), S).
finally(goal(P2, U2), S):-
    finally(outcome(_,_,_,P2,_,U2), S).

The verbal description of a tit-for-tat strategy is as follows:

"The tit-for-tat strategy begins with a default move. Then, in each subsequent interaction, it mirrors the opponent's previous move.".

Its Prolog representation for the game specified above can be defined as follows:

% tit-for-tat strategy
select(P, O, S, M):-
    \+ holds(last_move(O, _LMo), S),
    holds(default_move(P, M), S).
select(_P, O, S, Mo):-
    holds(last_move(O, Mo), S).

The verbal description of an anti-tit-for-tat strategy is as follows:

"The anti-tit-for-tat strategy begins with a default move. Then, in each subsequent interaction, it selects a move opposite to the opponent's previous move.".

Its Prolog representation for the game specified above can be defined as follows:

% tit-for-tat strategy
select(P, O, S, M):-
    \+ holds(last_move(O, _LMo), S),
    holds(default_move(P, M), S).
select(_P, O, S, M):-
    holds(last_move(O, Mo), S),
    opposite_move(Mo, M).

The verbal description of a random strategy is as follows:

"Selects a move at random with uniform probability."

Its Prolog representation for the game specified above can be defined as follows:

% random strategy
select(_P, _O, Ms, M):-
	random(0, 1.0, RN),                                  % Generate random number
	round_to_decimal_places(RN, 3, floor, RRN),          % Round it down.
	length(Ms, L),                                       % Find length of list
	Thresh is  1 / L,    			             % Find threashold
	round_to_decimal_places(Thresh, 3, floor, RThresh),  % Round it
	once((
		idxmember(I, Ms, M),
		UL is I*RThresh,
		round_to_decimal_places(UL, 3, floor, RUL),  % Check it succeeds
		RRN < RUL
	)).

idxmember(I, L, El):-
	nth0(Ii, L, El),
	I is Ii + 1.

% Library for random strategy.

/* Need a generic rounding predicate.

- Number is the real number you want to round.
- DecimalPlaces is the number of decimal places you want to round to.
- RoundingFunction can be 'ceil' or 'floor'.

Like rounding up in XL - here we use ceil(ing) as the name of the fn to call.
?- round_to_decimal_places(2.345, 2, ceil, Result).
Result = 2.35.

Like rounding down in XL - here we use floor as the name of the fn to call.
?- round_to_decimal_places(2.345, 2, floor, Result).
Result = 2.34.

*/

round_to_decimal_places(Number, DecimalPlaces, RoundingFunction, RoundedNumber) :-
    Multiplier is 10^DecimalPlaces,            % Multiplier for the specified decimal places
    call(RoundingFunction, Number * Multiplier, Temp), % Apply the rounding function (ceil or floor)
    RoundedNumber is Temp / Multiplier.        % Divide to get the result

The verbal description of a best response strategy is as follows:

"The best response strategy begins with a default move. Then, in each subsequent interaction, it selects the move that would give the highest payoff against the opponent's previous move."

Its Prolog representation for the game specified above can be defined as follows:

% Best move according to the behaviour of the opponent
% in the last game.
select(P, O, S, M):-
    \+ holds(last_move(O, _), S),
    holds(default_move(P, M),S).
select(P, O, S, M):-
    holds(last_move(O, LMo), S),
    findall(Ui-Mi, (game(S, F), finally(outcome(P, Mi, Ui, O, LMo, Uo), F), Ui >= Uo), Options),
    sort(0, @>, Options, Ranked),
    highest(Ranked, M).

% assumes a ranked list of pairs of the form 'Utility - Move',
% the rank is according to Utility. Returns the first one, and
% any other ones, if they have the same utility. If the list
% is empty, i.e. there is no best move, then it returns 'nil'.
highest([_-M|_], M).
highest([U-_|R], Mi):-
    member(U-Mi, R).
highest([], nil).

Here is a description of a different game and a strategy:

{game_description}

Produce game-specific predicates for the described game and predicates for the described strategy. Implement all logic necessary for using the code to actually play the game. Mark the beginning and end of the Prolog code with a '@'. Do not put any non-Prolog syntax between '@' characters.